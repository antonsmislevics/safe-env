{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Safe Environment Manager (safe-env)","text":"<p>Safe Environment Manager allows to manage secrets in environment variables in a safe way. To achieve this, safe-env follows a set of principles:</p> <ol> <li>Configurations for different environments are stored in a set of yaml files, that have no secrets and can be safely pushed to git repository.</li> <li>Secrets are never written to local files, even temporarily (Note: also it is possible to save the output in the file, this is not recommended, and should be considered only as an exception for short term temporary use).</li> <li>Secrets are stored in one of the following safe locations:<ul> <li>the resource itself (for example, access key in Azure Storage Account configuration);</li> <li>external vault (for example, Azure KeyVault);</li> <li>local keyring;</li> <li>environment variables (in memory).</li> </ul> </li> <li>Access to required resources and vaults is controlled via standard user authentication mechanisms (for example, <code>az login</code> or interactive browser login for Azure).</li> </ol> <p>Let's get started!</p>"},{"location":"getting-started/","title":"Getting started","text":"<p>In this section we cover how to install safe-env, and check that the installation was successful.</p>"},{"location":"getting-started/#how-to-install","title":"How to install?","text":"<p>The package can be installed using pip: <pre><code>python -m pip install safe-env\n</code></pre></p> <p>If using uv, it can be installed globally as a tool or as a dev dependency in specific project: <pre><code># install as a tool\nuv tool safe-env\n\n# or add as dev dependency\nuv add safe-env --dev\n</code></pre></p> <p>Latest dev version can also be installed directly from git repository: <pre><code># pip\npython -m pip install git+https://github.com/antonsmislevics/safe-env.git\n\n# uv as a tool\nuv tool install git+https://github.com/antonsmislevics/safe-env.git\n\n# uv as dev dependency\nuv add git+https://github.com/antonsmislevics/safe-env.git --dev\n</code></pre></p> <p>The package does not require to be installed in the same virtual environment that is used for development.</p>"},{"location":"getting-started/#how-to-use","title":"How to use?","text":"<p>When the package is installed, safe-env can be invoked from the command line as <code>se</code> or as <code>python -m safe_env</code>.</p> <p>To check the version of the tool, run: <pre><code>se --version\n\n# or\n\npython -m safe_env --version\n</code></pre></p> <p>To get a list of all available commands and options, run: <pre><code>se --help\n\n# or\n\npython -m safe_env --help\n</code></pre> Congratulations! Now you are ready to create environment configuration files.</p>"},{"location":"plugins/","title":"Developing plugins","text":"<p>Real-life software development projects are very different. It is expected, that safe-env users might need to load secrets from various specific sources, use different authentication providers or caches. Also, we plan to expand the list of integrations supported out of the box, we will never be able to cover all scenarios.</p> <p>That's why safe-env comes with built-in support for custom plugins - an easy way to execute your custom Python code when resolving environment configurations.</p>"},{"location":"plugins/#enabling-plugins","title":"Enabling plugins","text":"<p>To start using plugins, you need to create <code>plugins</code> subfolder in a folder where your environment configuration files are located and put <code>__init__.py</code> file in it:</p> ./envs/plugins/__init__.py<pre><code># import required dependecies\n\nCUSTOM_RESOLVERS = []       # register custom OmegaConf resolvers\nCUSTOM_CALLABLES = {}       # register custom shortcut names for callables, that can be used with se.call\nCUSTOM_AUTH_CLASSES = {}    # register custom shortcut names for auth providers, that can be used with se.auth\nCUSTOM_CACHE_CLASSES = {}   # register custom shortcut names for cache providers, that can be used with se.cache\n</code></pre>"},{"location":"plugins/#developing-plugins_1","title":"Developing plugins","text":"<p>Now safe-envs treats plugins folder as a regular Python module named <code>_plugins_</code>. This allows to organize Python code in multiple files and easily invoke it from environment configurations.</p> <p>Here is an example: ./envs/plugins/auth.py<pre><code>def my_custom_auth():\n    # implementation of custom authentication provider\n    return None    # returns some credentials object\n</code></pre></p> ./envs/plugins/call.py<pre><code>def my_custom_call():\n    # implementation of custom callable to retrieve secrets\n    return None    # returns object with secrets\n</code></pre> ./envs/plugins/cache.py<pre><code>from safe_env.cache_providers import BaseCacheProvider\n\n# implement custom cache provider\nclass MyCustomCacheProvider(BaseCacheProvider):\n    def __init__(self):\n        # constructor\n        super().__init__()\n\n    def _get(self, name: str):\n        # get secret\n        return None # return retrieved secret or None\n\n    def _set(self, name: str, value: Any):\n        # save secret\n        pass\n\n    def _delete(self, name: str):\n        # delete secret\n        pass\n</code></pre> ./envs/plugins/resolvers.py<pre><code>def my_custom_resolver():\n    # implementation of custom OmegaConf resolver\n    return None     # returns some value\n</code></pre> ./envs/plugins/__init__.py<pre><code># import required dependecies\nfrom safe_env.models import ResolverConfiguration\nfrom .auth import my_custom_auth\nfrom .call import my_custom_call\nfrom .cache import MyCustomCacheProvider\nfrom .resolvers import my_custom_resolver\n\n# register custom OmegaConf resolvers\nCUSTOM_RESOLVERS = [\n    ResolverConfiguration(\n        name=\"my.custom_resolver\",\n        func=my_custom_resolver,\n        use_cache=False\n    )\n]\n\n# register custom shortcut names for callables, that can be used with se.call\nCUSTOM_CALLABLES = {\n    \"my_custom_call_method\": my_custom_call\n}\n\n# register custom shortcut names for auth providers, that can be used with se.auth\nCUSTOM_AUTH_CLASSES = {\n    \"my_custom_auth_provider\": my_custom_auth\n}\n\n# register custom shortcut names for cache providers, that can be used with se.cache\nCUSTOM_CACHE_CLASSES = {\n    \"my_custom_cache\": MyCustomCacheProvider\n}\n</code></pre>"},{"location":"plugins/#invoking-plugins","title":"Invoking plugins","text":"<p>Now we can invoke plugins from environment configuration files, via OmegaConf resolvers, using custom shortcut names, or full names of callables.</p> Invoking custom resolvers<pre><code>    value: ${my.custom_resolver:}\n</code></pre> Invoking custom callables<pre><code>    value: ${se.call:my_custom_call_method}\n\n    # or\n\n    value: ${se.call:_plugins_.my_custom_call}\n</code></pre> Invoking custom auth providers<pre><code>    value: ${se.auth:my_custom_auth_provider}\n\n    # or\n\n    value: ${se.auth:_plugins_.my_custom_auth}\n</code></pre> Invoking custom cache providers<pre><code>    # ...\n    cache:\n      my_cache_name:\n        name: my_cache_key\n        provider: ${se.cache:MyCustomCacheProvider}\n    # ...\n\n    # or\n\n    # ...\n    cache:\n      my_cache_name:\n        name: my_cache_key\n        provider: ${se.cache:_plugins_.MyCustomCacheProvider}\n    # ...\n</code></pre>"},{"location":"working-with-envs/","title":"Working with environments","text":"<p>In this section we cover how to define and use environment configuration files for safe-env.</p>"},{"location":"working-with-envs/#how-to-define-environments","title":"How to define environments?","text":"<p>To start using safe-env you first need to create environment configuration files. By default the tool looks for these files in ./envs folder. However, custom path can be provided via <code>--config-dir</code> option.</p> <p>Configuration files are based on OmegaConf, and have only two special sections: <pre><code>depends_on:     # the list of \"parent\" environment configurations (optional)\nenvs:           # dictionary with resulting environment variables\n</code></pre></p> <p>Configuration files can be parametrized using standard OmegaConf variable interpolation and resolvers.</p> <p>Here are three examples of simple configuration files. To keep things simple, we are not loading any secrets yet - this will be covered later.</p> <p>This is a base environment configuration file. ./envs/base.yaml<pre><code>params:\n  param1: param1_value\n  param2: param2_value\n  param3: param3_value\n  env_name: base_env\nenvs:\n  var1: var1\n  var2: \"${params.param1} - ${params.param2}\"\n  var3: ${params.param3}\n  env_name: ${params.env_name}\n</code></pre></p> <p>This is a development environment configuration file. It inherits from base and overrides one parameter and one environment variable. ./envs/dev.yaml<pre><code>depends_on:\n  - base\nparams:\n  env_name: dev_env\nenvs:\n  var1: dev_var1\n</code></pre></p> <p>This is an example of a configuration file that could be used as an add-on when working in corporate environment behind the proxy. ./envs/local.yaml<pre><code>envs:\n  http_proxy: \"http-proxy-url\"\n  https_proxy: \"https-proxy-url\"\n  no_proxy: \"no-proxy-configuration\"\n</code></pre></p>"},{"location":"working-with-envs/#how-to-load-environment","title":"How to load environment?","text":"<p>First, let's list available environment configurations:</p> <pre><code>$ se list\n\n+-------+-----------------+\n| Name  |      Path       |\n+-------+-----------------+\n| base  | envs/base.yaml  |\n|  dev  |  envs/dev.yaml  |\n| local | envs/local.yaml |\n+-------+-----------------+\n</code></pre> <p>Now we can inspect how loaded environment variables for base and dev environments look.</p> <pre><code>$ se activate base\n\nvar1: var1\nvar2: param1_value - param2_value\nvar3: param3_value\nenv_name: base_env\n\n$ se activate dev\n\nvar1: dev_var1\nvar2: param1_value - param2_value\nvar3: param3_value\nenv_name: dev_env\n</code></pre> <p>And if we are working with dev environment behind the proxy, we can add local environment configuration as an add-on.</p> <pre><code>$ se activate dev local\n\nvar1: dev_var1\nvar2: param1_value - param2_value\nvar3: param3_value\nenv_name: dev_env\nhttp_proxy: http-proxy-url\nhttps_proxy: https-proxy-url\nno_proxy: no-proxy-configuration\n</code></pre> <p>Finally, we need to set values of these environment variables in the current working shell or in the process where our application will be executed. Depending on your situation, there are several ways do this.</p>"},{"location":"working-with-envs/#option-1-run-process-application","title":"Option 1: Run process / application","text":"<p>First, we can call <code>se run</code> to run another process / application with loaded environment variables.</p> <p>For example: <pre><code># run printenv to show which environment variables are set in sub process\n# NOTE: --no-host-envs option specifies that other environment variables from the host will not be available to subprocess\n$ se run dev --no-host-envs --cmd \"printenv\"\n\nvar1=dev_var1\nvar2=param1_value - param2_value\nvar3=param3_value\nenv_name=dev_env\n</code></pre></p> <p>If another application is a Python module, we can run it with <code>--python-module</code> or <code>-py</code> option:</p> <pre><code>$ se run dev --no-host-envs -py --cmd \"uvicorn my_fastapi_webapp.app:app --reload --port 8080 --host 0.0.0.0\"\n</code></pre> <p>In this case safe-env will configure environment variables and invoke this module in the same process. As a result, the following debug configuration in VSCode launch.json will start web application with environment variables for dev configuration and attach a debugger:</p> .vscode/launch.json<pre><code>// ... \n{\n    \"name\": \"Debug FastAPI with dev env variables\",\n    \"type\": \"debugpy\",\n    \"request\": \"launch\",\n    \"module\": \"safe_env\",\n    \"args\": [\"run\", \"dev\", \"-py\", \"--cmd\", \"uvicorn my_fastapi_webapp.app:app --reload --port 8080 --host 0.0.0.0\"],\n    \"cwd\": \"${workspaceFolder}\"\n}\n// ... \n</code></pre>"},{"location":"working-with-envs/#option-2-set-environment-variables-in-current-shell","title":"Option 2: Set environment variables in current shell","text":"<p>Second, we can call <code>se activate</code> passing a type of a shell as additional parameter. This allows to generate scripts that can be used to set environment variables in the current shell session.</p> bashPowerShellCommand Prompt <pre><code># preview the script\n$ se activate dev --bash\n\nexport var1=\"dev_var1\";export var2=\"param1_value - param2_value\";export var3=\"param3_value\";export env_name=\"dev_env\"\n\n# execute the script to set env variables\n$ eval $(se activate dev --bash)\n</code></pre> <pre><code># preview the script\n&gt; se activate dev --ps\n\n$env:var1=\"dev_var1\";$env:var2=\"param1_value - param2_value\";$env:var3=\"param3_value\";$env:env_name=\"dev_env\"\n\n# execute the script\n&gt; Invoke-Expression $(se activate dev --ps)\n</code></pre> <pre><code># preview the script\n&gt; se activate dev --cmd\n\nset \"var1=dev_var1\";set \"var2=param1_value - param2_value\";set \"var3=param3_value\";set \"env_name=dev_env\"\n\n# copy/paste to execute the script manually\n</code></pre>"},{"location":"working-with-envs/#option-3-generate-the-file-for-use-with-docker","title":"Option 3: Generate the file for use with Docker","text":"<p>If you work with Docker, you can also generate the file that can pass these environment variables from host to container via docker compose. In combination with Option 1 or Option 2 above, this allows to deliver environment variables to Docker container, without saving them to file. <pre><code># preview docker compose env file content\n$ se activate dev --docker\n\nvar1=${var1}\nvar2=${var2}\nvar3=${var3}\nenv_name=${env_name}\n\n# write to .env file\n$ se activate dev --docker --out docker-dev.env\n</code></pre></p>"},{"location":"working-with-envs/#option-4-generate-env-file-not-recommended","title":"Option 4: Generate .env file (not recommended)","text":"<p>Finally, you can generate <code>.env</code> file containing all values, and use it with Docker or other tools. <pre><code># preview env file content\n$ se activate dev --env\n\nvar1=dev_var1\nvar2=param1_value - param2_value\nvar3=param3_value\nenv_name=dev_env\n\n# write to .env file\n$ se activate dev --env --out dev.env\n</code></pre></p> <p>Important</p> <p>Please note that since this file will contain all values, including secrets, it is recommended to:</p> <ol> <li>use such files only if there is no option to load values from in-memory environment variables;</li> <li>delete this file immediately after use.</li> </ol>"},{"location":"working-with-envs/#how-to-definedebug-more-complex-config-files","title":"How to define/debug more complex config files?","text":"<p>Configs in previous examples were simple. When defining more complex configs <code>se resolve</code> command helps to debug variable interpolation and resolvers. It returns the entire config yaml file, with all values resolved.</p> Debug dev configurationDebug dev+local configuration <pre><code>$ se resolve dev\n\nparams:\n  param1: param1_value\n  param2: param2_value\n  param3: param3_value\n  env_name: dev_env\nenvs:\n  var1: dev_var1\n  var2: param1_value - param2_value\n  var3: param3_value\n  env_name: dev_env\n</code></pre> <pre><code>$ se resolve dev local\n\nparams:\n  param1: param1_value\n  param2: param2_value\n  param3: param3_value\n  env_name: dev_env\nenvs:\n  var1: dev_var1\n  var2: param1_value - param2_value\n  var3: param3_value\n  env_name: dev_env\n  http_proxy: http-proxy-url\n  https_proxy: https-proxy-url\n  no_proxy: no-proxy-configuration\n</code></pre> <p>Congratulations! Now you are ready to start loading secrets.</p>"},{"location":"working-with-secrets/","title":"Working with secrets","text":"<p>In this section we cover how to efficiently handle secrets in environment configuration files using safe-env.</p>"},{"location":"working-with-secrets/#overview","title":"Overview","text":"<p>A set of custom OmegaConf resolvers is included to work with secrets in a secure way:</p> <ul> <li><code>se.call</code> - allows to invoke any Python callable </li> <li><code>se.auth</code> - shortcut to invoke classes generating credentials for authentication to various sources</li> <li><code>se.cache</code> - shortcut to invoke classes providing caching capabilities</li> </ul> <p>It is important to highlight, that all resolvers are implemented in a way that parent config element is used as a container that stores configurations on how callable will be invoked.</p> <p>Here is a sample configuration file showing how these resolvers work together: <pre><code># common params, that are typically overridden in nested configurations\nparams:\n  tenant_id: &lt;tenant-id&gt;\n  az_storage_account_name: &lt;storage-account-name&gt;\n  kv_url: https://&lt;keyvaylt-name&gt;.vault.azure.net/\n  kv_secret_postfix: DEV\n  keyring_postfix: dev\n\n# retrieve credentials required for authentication\ncredentials:\n  azure_identity:\n    value: ${se.auth:azure.interactive}           # use azure interactive login\n    kwargs:\n      tenant_id: ${params.tenant_id}\n    cache:                                        # cache credentials, so we don't need to login multiple times\n      memory:\n        name: azure_credential                    # key to be used when storing object in memory\n        provider: ${se.cache:memory}              # use in-memory cache\n        required: True\n\n# dynamically construct Azure KeyVault secret names for different environments\n# in this example we assume that the same KeyVault is used for all environments and different postfixes are used\nkv_key_names:\n  app_client_id: APPCLIENTID${params.kv_secret_postfix}\n  app_client_secret: APPCLIENTSECRET${params.kv_secret_postfix}\n\n# retrieve secret from Azure KeyVault\nkv_secrets:\n  value: ${se.call:get_azure_key_vault_secrets}     # here we use a registered/known shortcut name for secrets resolver, \n                                                    # but we could also use the full name of the callable instead\n  as_container: True                                # convert returned result to OmegaConf container\n  kwargs:\n    url: ${params.kv_url}\n    credential: ${credentials.azure_identity.value} # use credentials for authentication\n    names:                                          # names of secrets to retrieve from KeyVault\n      - AZSTORAGEACCOUNTKEY\n      - ${kv_key_names.app_client_id}\n      - ${kv_key_names.app_client_secret}\n  cache:\n    local_keyring:                                  # cache secrets locally, so we don't need to go to KeyVault every time\n      name: kv_secrets_${params.keyring_postfix}    # secret name in the cache\n      provider: ${se.cache:keyring}                 # use local keyring as a cache\n      init_params:\n        kwargs:\n          service_name: my_app_secrets              # service name in the cache\n\n# construct final environment variables\nenvs:                                               \n  AZ_ACCOUNT_NAME: ${params.az_storage_account_name}\n  AZ_ACCOUNT_KEY: ${kv_secrets.value.AZSTORAGEACCOUNTKEY}\n  APP_CLIENT_ID: ${kv_secrets.value.${kv_key_names.app_client_id}}\n  APP_CLIENT_SECRET: ${kv_secrets.value.${kv_key_names.app_client_secret}}\n</code></pre></p> <p>Running <code>se resolve</code> shows how this configuration will be resolved with values: <pre><code>params:\n  tenant_id: &lt;tenant-id&gt;\n  az_storage_account_name: &lt;storage-account-name&gt;\n  kv_url: https://&lt;keyvaylt-name&gt;.vault.azure.net/\n  kv_secret_postfix: DEV\n  keyring_postfix: dev\ncredentials:\n  azure_identity:\n    value: !&lt;object&gt; 'safe_env.resolvers.delayedcallable.DelayedCallable'\n    kwargs:\n      tenant_id: &lt;tenant-id&gt;\n    cache:\n      memory:\n        name: azure_credential\n        provider: !!python/name:safe_env.cache_providers.memory_cache.MemoryCache ''\n        required: true\nkv_key_names:\n  app_client_id: APPCLIENTIDDEV\n  app_client_secret: APPCLIENTSECRETDEV\nkv_secrets:\n  value:\n    AZSTORAGEACCOUNTKEY: &lt;storage-account-key&gt;\n    APPCLIENTIDDEV: &lt;app-client-id&gt;\n    APPCLIENTSECRETDEV: &lt;app-client-secret&gt;\n  as_container: true\n  kwargs:\n    url: https://&lt;keyvaylt-name&gt;.vault.azure.net/\n    credential: !&lt;object&gt; 'safe_env.resolvers.delayedcallable.DelayedCallable'\n    names:\n    - AZSTORAGEACCOUNTKEY\n    - APPCLIENTIDDEV\n    - APPCLIENTSECRETDEV\n  cache:\n    local_keyring:\n      name: kv_secrets_dev\n      provider: !!python/name:safe_env.cache_providers.keyring_cache.KeyringCache ''\n      init_params:\n        kwargs:\n          service_name: my_app_secrets\nenvs:\n  AZ_ACCOUNT_NAME: &lt;storage-account-name&gt;\n  AZ_ACCOUNT_KEY: &lt;storage-account-key&gt;\n  APP_CLIENT_ID: &lt;app-client-id&gt;\n  APP_CLIENT_SECRET: &lt;app-client-secret&gt;\n</code></pre></p>"},{"location":"working-with-secrets/#loading-secrets","title":"Loading secrets","text":"<p>Depending on project specifics, secrets may need to be loaded from different sources. For example, if the project is relying on Microsoft Azure cloud infrastructure, secrets may be loaded from Azure KeyVault or directly from Azure resources (for example, access keys to specific resources). Safe-env supports such scenarios by allowing to invoke arbitrary python code, what gives unlimited integration possibilities.</p> <p>To invoke custom code from configuration file, <code>se.call</code> resolver should be used:</p> <pre><code># retrieve secret from Azure KeyVault\nkv_secrets:\n  value: ${se.call:get_azure_key_vault_secrets}     # here we use a registered/known shortcut name for secrets resolver, \n                                                    # but we could also use the full name of the callable instead\n  as_container: True                                # convert returned result to OmegaConf container\n  kwargs:\n    url: ${params.kv_url}\n    credential: ${credentials.azure_identity.value} # use credentials for authentication\n    names:                                          # names of secrets to retrieve from KeyVault\n      - AZSTORAGEACCOUNTKEY\n      - ${kv_key_names.app_client_id}\n      - ${kv_key_names.app_client_secret}\n  cache:\n    local_keyring:                                  # cache secrets locally, so we don't need to go to KeyVault every time\n      name: kv_secrets_${params.keyring_postfix}    # secret name in the cache\n      provider: ${se.cache:keyring}                 # use local keyring as a cache\n      init_params:\n        kwargs:\n          service_name: my_app_secrets              # service name in the cache\n</code></pre> <p>As argument <code>se.call</code> expects full name of a callable, or registered \"known\" shortcut name. In this case, <code>get_azure_key_vault_secrets</code> is known shortcut name for <code>safe_env.resolvers.callables_azure.get_azure_key_vault_secrets</code>: ./src/safe_env/resolvers/callables_azure.py<pre><code>def get_azure_key_vault_secrets(\n    url: str,\n    credential: Any,\n    names: List[str]\n) -&gt; Dict[str, Any]:\n  # ...\n</code></pre></p> <p>safe-env comes with a set of \"known\" shortcut names, which are registered via:</p> <p>./src/safe_env/resolvers/callables.py<pre><code># ...\nKNOWN_CALLABLES = {\n    \"get_azure_key_vault_secrets\": get_azure_key_vault_secrets,\n    \"get_keyring_secrets\": get_keyring_secrets,\n    \"get_azure_rest_resource\": get_azure_rest_resource,\n    \"get_azure_devops_pat\": get_azure_devops_pat\n}\n# ...\n</code></pre> Usually, a callable expects that specific arguments are provided during invocation. For example, <code>get_azure_key_vault_secrets</code> expects that three arguments are provided: url, credential and names of secrets. <code>se.call</code> allows to provide these arguments via <code>args</code> and <code>kwargs</code> attributes under the same parent in configuration file: <pre><code># retrieve secret from Azure KeyVault\nkv_secrets:\n  value: ${se.call:get_azure_key_vault_secrets}     # here we use a registered/known shortcut name for secrets resolver, \n                                                    # but we could also use the full name of the callable instead\n  as_container: True                                # convert returned result to OmegaConf container\n  kwargs:\n    url: ${params.kv_url}\n    credential: ${credentials.azure_identity.value} # use credentials for authentication\n    names:                                          # names of secrets to retrieve from KeyVault\n      - AZSTORAGEACCOUNTKEY\n      - ${kv_key_names.app_client_id}\n      - ${kv_key_names.app_client_secret}\n  cache:\n    local_keyring:                                  # cache secrets locally, so we don't need to go to KeyVault every time\n      name: kv_secrets_${params.keyring_postfix}    # secret name in the cache\n      provider: ${se.cache:keyring}                 # use local keyring as a cache\n      init_params:\n        kwargs:\n          service_name: my_app_secrets              # service name in the cache\n</code></pre></p> <p>This callable will return a dictionary with names/values for each secret name. However, this dictionary is not a valid OmegaConf container. <code>as_container: True</code> attribute tells <code>se.call</code> that we want to convert returned object to a valid container. This allows us to use values from it as: <pre><code>  AZ_ACCOUNT_KEY: ${kv_secrets.value.AZSTORAGEACCOUNTKEY}\n</code></pre> Alternatively, if not all values returned by the callable are required, it is possible to apply JMESPath expression on returned value, via <code>selector</code> attribute: <pre><code>  # ...\n  value: ${se.call:some_method}\n  selector: \"&lt;JMESPath expression to apply on returned value&gt;\"\n  # ...\n</code></pre></p> <p>Finally, in more complex scenarios, we may want <code>se.call</code> to initialize an instance of the class first, and then invoke specific method from this class. This can be achieved by using the following attributes: <pre><code>  # ...\n  value: ${se.call:&lt;full name of the class&gt;}  # full name of the class as a callable passed to se.call\n  init_params:    # parameters passed to constructor\n    args:         # list of args for constructor\n    kwargs:       # dictionary with kwargs for constructor\n  method:         # name of the method to invoke from class instance\n  args:           # list of args for method\n  kwargs:         # dictionary with kwargs for method\n  # ...\n</code></pre></p>"},{"location":"working-with-secrets/#caching","title":"Caching","text":"<p>Typically, secrets do not change every day. That's why, to improve developer experience, it may be good to cache them in a secure local storage. Good common choice is to use local keyring - the same storage, that operating system uses to store user secrets.</p> <p>safe-env allows to cache retrieved secrets via <code>cache</code> attribute: <pre><code># retrieve secret from Azure KeyVault\nkv_secrets:\n  value: ${se.call:get_azure_key_vault_secrets}     # here we use a registered/known shortcut name for secrets resolver, \n                                                    # but we could also use the full name of the callable instead\n  as_container: True                                # convert returned result to OmegaConf container\n  kwargs:\n    url: ${params.kv_url}\n    credential: ${credentials.azure_identity.value} # use credentials for authentication\n    names:                                          # names of secrets to retrieve from KeyVault\n      - AZSTORAGEACCOUNTKEY\n      - ${kv_key_names.app_client_id}\n      - ${kv_key_names.app_client_secret}\n  cache:\n    local_keyring:                                  # cache secrets locally, so we don't need to go to KeyVault every time\n      name: kv_secrets_${params.keyring_postfix}    # secret name in the cache\n      provider: ${se.cache:keyring}                 # use local keyring as a cache\n      init_params:\n        kwargs:\n          service_name: my_app_secrets              # service name in the cache\n</code></pre></p> <p>The attribute allows to specify one or multiple caches as a dictionary. If multiple caches are configured, they will be treated as being ordered alphabetically by dictionary key.</p> <p>For each cache we must specify:</p> <ul> <li><code>name</code> - the name that will be used to store secret in the cache</li> <li><code>provider</code> - <code>se.cache</code> resolver with a full name of a callable, or registered \"known\" shortcut cache name.</li> </ul> <p>In this case, <code>keyring</code> is a known shortcut name for <code>safe_env.cache_providers.AzureKeyVaultSecretCache</code>: ./src/cache_providers/keyring_cache.py<pre><code># ...\nfrom .base_cache_provider import BaseCacheProvider\n\nclass KeyringCache(BaseCacheProvider):\n    def __init__(self, keyring_type: str = None, service_name: str = None, **kwargs):\n        super().__init__(**kwargs)\n        self.keyring_type = keyring_type\n        self.default_service_name = service_name\n# ...\n</code></pre></p> <p>safe-env comes with a set of \"known\" shortcut cache names, which are registered via:</p> ./src/safe_env/resolvers/cache.py<pre><code># ...\nKNOWN_CACHE_CLASSES = {\n    \"memory\": cache_providers.MemoryCache,\n    \"keyring\": cache_providers.KeyringCache,\n    \"azure.keyvault\": cache_providers.AzureKeyVaultSecretCache\n}\n# ...\n</code></pre> <p>Constructor of cache provider class may expect, that specific arguments are provided. For example, <code>KeyringCache</code> expects that <code>service_name</code> is provided. Same as with <code>se:call</code> this can be done via: <pre><code>  # ...\n  init_params:    # parameters passed to constructor\n    args:         # list of args for constructor\n    kwargs:       # dictionary with kwargs for constructor\n  # ...\n</code></pre></p> <p>safe-env comes with few commands / options that help to manage caches: <pre><code>$ se flush    # Delete values stored in all caches for specified environments.\n\n$ se (resolve | activate | run) (--force-reload | -f)   # Ignore all cached values and reload from sources.\n\n$ se (resolve | activate | run) (--no-cache | -n)   # Do not use caches to load/save values.\n</code></pre></p> <p>However, some caches are \"technical\" and should always be used - for example, in-memory cache for storing authentication credentials. To achieve this, we can mark specific cache as <code>required</code>: <pre><code>  # retrieve credentials required for authentication\ncredentials:\n  azure_identity:\n    value: ${se.auth:azure.interactive}           # use azure interactive login\n    kwargs:\n      tenant_id: ${params.tenant_id}\n    cache:                                        # cache credentials, so we don't need to login multiple times\n      memory:\n        name: azure_credential                    # key to be used when storing object in memory\n        provider: ${se.cache:memory}              # use in-memory cache\n        required: True\n</code></pre></p>"},{"location":"working-with-secrets/#authentication","title":"Authentication","text":"<p>Usually, retrieving secrets requires some form of authentication. For example, if secrets are stored in Azure, the user is required to authenticate via <code>az login</code> or interactive browser login.</p> <p>safe-env allows to invoke a callable to retrieve authentication credentials via <code>se.auth</code> resolver: <pre><code>  # retrieve credentials required for authentication\ncredentials:\n  azure_identity:\n    value: ${se.auth:azure.interactive}           # use azure interactive login\n    kwargs:\n      tenant_id: ${params.tenant_id}\n    cache:                                        # cache credentials, so we don't need to login multiple times\n      memory:\n        name: azure_credential                    # key to be used when storing object in memory\n        provider: ${se.cache:memory}              # use in-memory cache\n        required: True\n</code></pre></p> <p>As argument <code>se.auth</code> expects a full name of a callable, or registered \"known\" shortcut auth provider name. In this case, <code>azure.interactive</code> is a known shortcut name for <code>azure.identity.InteractiveBrowserCredential</code>.</p> <p>safe-env comes with a set of \"known\" shortcut auth provider names, which are registered via:</p> ./src/safe_env/resolvers/auth.py<pre><code># ...\nKNOWN_AUTH_CLASSES = {\n    \"azure.default\": DefaultAzureCredential,\n    \"azure.cli\": AzureCliCredential,\n    \"azure.interactive\": InteractiveBrowserCredential,\n    \"azure.managedidentity\": ManagedIdentityCredential,\n    \"azure.devicecode\": DeviceCodeCredential,\n    \"azure.vscode\": VisualStudioCodeCredential,\n    \"azure.token\": get_azure_credential_token\n}\n# ...\n</code></pre> <p>Arguments to auth provider can be provided via: <pre><code>  # ...\n  args:           # list of args\n  kwargs:         # dictionary with kwargs\n  # ...\n</code></pre></p> <p>Since the same credentials might be used multiple times, while resolving configuration file, it is a good idea to cache them in-memory:</p> <pre><code>  # retrieve credentials required for authentication\ncredentials:\n  azure_identity:\n    value: ${se.auth:azure.interactive}           # use azure interactive login\n    kwargs:\n      tenant_id: ${params.tenant_id}\n    cache:                                        # cache credentials, so we don't need to login multiple times\n      memory:\n        name: azure_credential                    # key to be used when storing object in memory\n        provider: ${se.cache:memory}              # use in-memory cache\n        required: True\n</code></pre> <p>Interesting Fact</p> <p>Technically <code>se.auth</code> is not a regular callable, but <code>safe_env.resolvers.delayedcallable.DelayedCallable</code>. It is invoked only when authentication credentials are really needed. For example, if secrets can be retrieved from the cache, <code>se.auth</code> will not ask the user for authentication credentials.</p> <p>Congratulations! Now you know all moving parts, and are ready to integrate safe-env with custom secret sources, authentication providers, or caches by implementing plugins.</p>"}]}